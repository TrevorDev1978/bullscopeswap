console.log('TransactionProvider loaded')
// client/context/TransactionContext.js
import React, { createContext, useEffect, useState } from 'react'
import { useAccount, useSendTransaction, useWaitForTransactionReceipt, useWriteContract } from 'wagmi'
import { parseEther } from 'viem'
import { contractABI, contractAddress } from '../lib/constants'
import { client } from '../lib/sanityClient'
import { useRouter } from 'next/router'

// Valori di default per evitare undefined
const defaultCtx = {
  currentAccount: null,
  connectWallet: () => {}, // gestito da RainbowKit
  sendTransaction: () => {},
  handleChange: () => {},
  formData: { addressTo: '', amount: '' },
  isLoading: false,
}

export const TransactionContext = createContext(defaultCtx)

export default function TransactionProvider({ children }) {
  const router = useRouter()
  const { address: currentAccount, isConnected } = useAccount()

  const [formData, setFormData] = useState({ addressTo: '', amount: '' })

  // A) invio nativo PLS
  const { sendTransactionAsync, data: txHashNative, isPending: isSendingNative } = useSendTransaction()
  // B) call al tuo router/contratto
  const { writeContractAsync, data: txHashRouter, isPending: isSendingRouter } = useWriteContract()

  const awaitedHash = txHashRouter ?? txHashNative
  const { isLoading: isConfirming, isSuccess, data: receipt } = useWaitForTransactionReceipt({
    hash: awaitedHash,
  })

  const isLoading = isSendingNative || isSendingRouter || isConfirming

  const handleChange = (e, name) => {
    setFormData(prev => ({ ...prev, [name]: e.target.value }))
  }

  const saveTransaction = async (hash, amount, fromAddress, toAddress) => {
    try {
      const txDoc = {
        _type: 'transactions',
        _id: hash,
        fromAddress,
        toAddress,
        timestamp: new Date(Date.now()).toISOString(),
        txHash: hash,
        amount: parseFloat(amount || '0'),
      }
      await client.createIfNotExists(txDoc)
      await client
        .patch(fromAddress)
        .setIfMissing({ transactions: [] })
        .insert('after', 'transactions[-1]', [{ _key: hash, _ref: hash, _type: 'reference' }])
        .commit()
    } catch (e) {
      console.error('Sanity save error:', e)
    }
  }

  const sendTransaction = async () => {
    const { addressTo, amount } = formData
    if (!isConnected) {
      console.warn('Wallet non connesso.')
      return
    }
    if (!addressTo || !amount) return

    try {
      const USE_ROUTER = process.env.NEXT_PUBLIC_USE_ROUTER === '1'

      if (USE_ROUTER) {
        // call al tuo router (se non è payable, rimuovi "value")
        const fnName = process.env.NEXT_PUBLIC_ROUTER_FN || 'publishTransaction'
        await writeContractAsync({
          address: contractAddress,
          abi: contractABI,
          functionName: fnName,
          args: [
            addressTo,
            parseEther(amount),
            `Transaction PLS ${amount} to ${addressTo}`,
            'TRANSFER',
          ],
          value: parseEther(amount), // rimuovi se la tua fn non è payable
        })
      } else {
        // invio nativo PLS
        await sendTransactionAsync({
          to: addressTo,
          value: parseEther(amount),
        })
      }

      setFormData({ addressTo: '', amount: '' })
    } catch (e) {
      console.error('sendTransaction error:', e)
    }
  }

  // crea/aggiorna profilo utente su Sanity all’aggiornarsi dell’account
  useEffect(() => {
    if (!currentAccount) return
    ;(async () => {
      try {
        const userDoc = {
          _type: 'users',
          _id: currentAccount,
          userName: 'Unnamed',
          address: currentAccount,
        }
        await client.createIfNotExists(userDoc)
      } catch (e) {
        console.error('Sanity user error:', e)
      }
    })()
  }, [currentAccount])

  // toggle della pagina “loading” come facevi prima
  useEffect(() => {
    if (isLoading) router.push(`/?loading=${currentAccount}`)
    else router.push('/')
  }, [isLoading, currentAccount, router])

  // quando confermata, salva su Sanity
  useEffect(() => {
    if (!isSuccess || !awaitedHash) return
    const to = receipt?.to || ''
    const from = currentAccount || ''
    // NB: se vuoi l'importo preciso, conservalo in una ref PRIMA di resettare formData
    saveTransaction(awaitedHash, formData.amount, from, to)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isSuccess, awaitedHash])

  return (
    <TransactionContext.Provider
      value={{
        currentAccount,
        connectWallet: () => {},
        sendTransaction,
        handleChange,
        formData,
        isLoading,
      }}
    >
      {children}
    </TransactionContext.Provider>
  )
}
